/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
PizzaKnobFilterPluginAudioProcessor::PizzaKnobFilterPluginAudioProcessor()
{
    UserParams[MasterBypass] = 0.0f;//default to not bypassed
	UserParams[Mode] = 0.0f;//default Width 1.0 (no change)
	UserParams[Freq] = 1.0f;//default Width 1.0 (no change)
	UserParams[Q] = 0.43f;//default Width 1.0 (no change)
	UserParams[Volume] = 1.0f;//default Width 1.0 (no change)

	UIUpdateFlag = true;//Request UI update
}

PizzaKnobFilterPluginAudioProcessor::~PizzaKnobFilterPluginAudioProcessor()
{
}

//==============================================================================
const String PizzaKnobFilterPluginAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

bool PizzaKnobFilterPluginAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool PizzaKnobFilterPluginAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool PizzaKnobFilterPluginAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double PizzaKnobFilterPluginAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int PizzaKnobFilterPluginAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int PizzaKnobFilterPluginAudioProcessor::getCurrentProgram()
{
    return 0;
}

void PizzaKnobFilterPluginAudioProcessor::setCurrentProgram (int index)
{
}

const String PizzaKnobFilterPluginAudioProcessor::getProgramName (int index)
{
    return String();
}

void PizzaKnobFilterPluginAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void PizzaKnobFilterPluginAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
}

void PizzaKnobFilterPluginAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void PizzaKnobFilterPluginAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    // In case we have more outputs than inputs, this code clears any output
	// channels that didn't contain input data, (because these aren't
	// guaranteed to be empty - they may contain garbage).
	// I've added this to avoid people getting screaming feedback
	// when they first compile the plugin, but obviously you don't need to
	// this code if your algorithm already fills all the output channels.
	/*
	for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
	buffer.clear (i, 0, buffer.getNumSamples());

	// This is the place where you'd normally do the guts of your plugin's
	// audio processing...
	for (int channel = 0; channel < getNumInputChannels(); ++channel)
	{
	float* channelData = buffer.getWritePointer (channel);

	// ..do something to the data...
	}
	*/
	
    //MIDI Process 
    int time;
    MidiMessage m;
    for (MidiBuffer::Iterator i (midiMessages); i.getNextEvent (m, time);)
    {
        if (m.isNoteOn())
        {
        }
        else if (m.isNoteOff())
        {
        }
        else if (m.isAftertouch())
        {
        }
        else if (m.isPitchWheel())
        {
        }
		else if (m.isController()) 
		{
			switch (m.getControllerNumber())
			{
			case 21:
				setParameter(Volume, (float) (m.getControllerValue()/127.0f));
				break;
			case 22:
				setParameter(Freq, (float)(m.getControllerValue() / 127.0f));
				break;
			case 23:
				setParameter(Q, (float)(m.getControllerValue() / 127.0f));
				break;
			default:
				break;
			}
		}
    }

	MultiFilter.SetFilter((int)UserParams[Mode],
							20.0 * pow(1000.0, UserParams[Freq]),
							0.1 * pow(200.0, UserParams[Q]),
							(float)getSampleRate());

	//Audio Process--------------------------------------------------------------
	if (getNumInputChannels()<2 || UserParams[MasterBypass])
	{
	}/*Nothing to do here - processing is in-place, so doing nothing is pass-through (for NumInputs=NumOutputs)*/
	else
	{//Not bypassed - do processing!
		buffer.applyGain(UserParams[Volume]);
		
		float* leftData = buffer.getWritePointer(0);
		float* rightData = buffer.getWritePointer(1);
		for (long i = 0; i < buffer.getNumSamples(); i++) {
			MultiFilter.ClockProcess(&leftData[i], &rightData[i]);
		}
	}
}

//==============================================================================
bool PizzaKnobFilterPluginAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* PizzaKnobFilterPluginAudioProcessor::createEditor()
{
    return new PizzaKnobFilterPluginAudioProcessorEditor (*this);
}

//==============================================================================
void PizzaKnobFilterPluginAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
	// You could do that either as raw data, or use the XML or ValueTree classes
	// as intermediaries to make it easy to save and load complex data.

	//Save UserParams/Data to file
	
	XmlElement root("Root");
	XmlElement *el;
	el = root.createNewChildElement("Bypass");
	el->addTextElement(String(UserParams[MasterBypass]));
	el = root.createNewChildElement("Mode");
	el->addTextElement(String(UserParams[Mode]));
	el = root.createNewChildElement("Freq");
	el->addTextElement(String(UserParams[Freq]));
	el = root.createNewChildElement("Q");
	el->addTextElement(String(UserParams[Q]));
	el = root.createNewChildElement("Volume");
	el->addTextElement(String(UserParams[Volume]));
	copyXmlToBinary(root, destData);
	
	/*
	// Create an outer XML element..
	XmlElement xml("MYPLUGINSETTINGS");

	// add some attributes to it..
	//xml.setAttribute("uiWidth", lastUIWidth);
	//xml.setAttribute("uiHeight", lastUIHeight);

	// Store the values of all our parameters, using their param ID as the XML attribute
	for (int i = 0; i < getNumParameters(); ++i)
		if (AudioProcessorParameterWithID* p = dynamic_cast<AudioProcessorParameterWithID*> (getParameters().getUnchecked(i)))
			xml.setAttribute(p->paramID, p->getValue());

	// then use this helper function to stuff it into the binary blob and return it..
	copyXmlToBinary(xml, destData);
	*/
}

void PizzaKnobFilterPluginAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
	// whose contents will have been created by the getStateInformation() call.

	//Load UserParams/Data from file
	
	XmlElement* pRoot = getXmlFromBinary(data, sizeInBytes);
	if (pRoot != NULL)
	{
		forEachXmlChildElement((*pRoot), pChild)
		{
			if (pChild->hasTagName("Bypass"))
			{
				String text = pChild->getAllSubText();
				setParameter(MasterBypass, text.getFloatValue());
			}
			else if (pChild->hasTagName("Mode"))
			{
				String text = pChild->getAllSubText();
				setParameter(Parameters::Mode , text.getFloatValue());
			}
			else if (pChild->hasTagName("Freq"))
			{
				String text = pChild->getAllSubText();
				setParameter(Parameters::Freq, text.getFloatValue());
			}
			else if (pChild->hasTagName("Q"))
			{
				String text = pChild->getAllSubText();
				setParameter(Parameters::Q, text.getFloatValue());
			}
			else if (pChild->hasTagName("Volume"))
			{
				String text = pChild->getAllSubText();
				setParameter(Parameters::Volume, text.getFloatValue());
			}
		}
		delete pRoot;	
	}
	
	/*
	// This getXmlFromBinary() helper function retrieves our XML from the binary blob..
	ScopedPointer<XmlElement> xmlState(getXmlFromBinary(data, sizeInBytes));

	if (xmlState != nullptr)
	{
		// make sure that it's actually our type of XML object..
		if (xmlState->hasTagName("MYPLUGINSETTINGS"))
		{
			// ok, now pull out our last window size..
			//lastUIWidth = xmlState->getIntAttribute("uiWidth", lastUIWidth);
			//lastUIHeight = xmlState->getIntAttribute("uiHeight", lastUIHeight);

			// Now reload our parameters..
			for (int i = 0; i < getNumParameters(); ++i)
				if (AudioProcessorParameterWithID* p = dynamic_cast<AudioProcessorParameterWithID*> (getParameters().getUnchecked(i)))
					p->setValueNotifyingHost((float)xmlState->getDoubleAttribute(p->paramID, p->getValue()));
		}
	}*/
	UIUpdateFlag = true;//Request UI update
}

//==============================================================================
int PizzaKnobFilterPluginAudioProcessor::getNumParameters()
{
	return totalNumParam;
}

//Get Return Filter Parameter range 0~1.0
float PizzaKnobFilterPluginAudioProcessor::getParameter(int index)
{
	switch (index)
	{
	case MasterBypass://example nothing special
		return UserParams[MasterBypass];
	case Mode://example update from internal
		return UserParams[Mode];
	case Freq://example update from internal
		return UserParams[Freq];
	case Q://example update from internal
		return UserParams[Q];
	case Volume://example update from internal
		return UserParams[Volume];
	default: return 0.0f;//invalid index
	}
}

//The host will call this method to change the value of one of the filter's parameters.
//The host may call this at any time, including during the audio processing callback, so the filter has to process this very fast and avoid blocking.
//If you want to set the value of a parameter internally, e.g. from your editor component, then don't call this directly - instead, use the setParameterNotifyingHost() method, which will also send a message to the host telling it about the change. If the message isn't sent, the host won't be able to automate your parameters properly.
//The value passed will be between 0 and 1.0.
//...
//Your filter can call this when it needs to change one of its parameters.
//This could happen when the editor or some other internal operation changes a parameter. 
//This method will call the setParameter() method to change the value, and will then send a message to the host telling it about the change.
//The value passed will be between 0 and 1.0.
void PizzaKnobFilterPluginAudioProcessor::setParameter(int index, float newValue)
{
	switch (index)
	{
	case MasterBypass:
		UserParams[MasterBypass] = newValue;
		break;
	case Mode:
		UserParams[Mode] = newValue;
		break;
	case Freq:
		UserParams[Freq] = newValue;
		break;
	case Q:
		UserParams[Q] = newValue;
		break;
	case Volume://example update from internal
		UserParams[Volume] = newValue;
		break;
	default: return;
	}
	UIUpdateFlag = true;//Request UI update -- Some OSX hosts use alternate editors, this updates ours
}

//return parameter Name as string to HOST.
const String PizzaKnobFilterPluginAudioProcessor::getParameterName(int index)
{
	switch (index)
	{
	case MasterBypass: return "Master Bypass";
	case Mode: return "Mode";
	case Freq: return "Freq";
	case Q: return "Q";
	case Volume: return "Volume";
	default:return String::empty;
	}
}

//return parameter value as string to HOST.
const String PizzaKnobFilterPluginAudioProcessor::getParameterText(int index)
{
	switch (index)
	{
	case MasterBypass: return String(UserParams[MasterBypass]);

	case Mode: return UserParams[Mode] < 1.0f ? "LowPass":"HighPass";

	case Freq:
        return String((int)(20.0 * pow(1000.0, UserParams[Freq]))) + String("Hz");
		
	case Q:            
		return String((0.1 * pow(200.0, UserParams[Q])), 2);

	case Volume: return String(UserParams[Volume]);

	default:return String::empty;
	}
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new PizzaKnobFilterPluginAudioProcessor();
}
